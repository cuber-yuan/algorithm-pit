{% extends "base.html" %}

{% block title %}Gomoku{% endblock %}

{% block sidebar_left %}
<aside class="sider-left">
  <div style="padding: 2rem;">
    <h2 style="font-size: 1.25rem; font-weight: bold;">Black</h2>
    <select id="aiSelectBlack" class="block w-full border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm">
      {% for bot in bots %}
      <option value="{{ bot[0] }}">{{ bot[1] }}</option>
      {% endfor %}
    </select>
    <div style="margin-top:1.5rem;">
      <input type="checkbox" id="left-checkbox" />
      <label for="left-checkbox" style="margin-left:0.5rem;">Human</label>
    </div>
  </div>
</aside>
{% endblock %}

{% block sidebar_right %}
<aside class="sider-right">
  <div style="padding: 2rem;">
    <h2 style="font-size: 1.25rem; font-weight: bold;">White</h2>
    <select id="aiSelectWhite" class="block w-full border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm">
      {% for bot in bots %}
      <option value="{{ bot[0] }}">{{ bot[1] }}</option>
      {% endfor %}
    </select>
    <div style="margin-top:1.5rem;">
      <input type="checkbox" id="right-checkbox" />
      <label for="right-checkbox" style="margin-left:0.5rem;">Human</label>
    </div>
  </div>
</aside>
{% endblock %}

{% block content %}
<!-- <script src="{{ url_for('static', filename='index.js') }}"></script> -->
<script src="https://cdn.socket.io/4.0.0/socket.io.min.js"></script>
<style>
  canvas {
    background: #f5deb3;
    margin-top: 20px;
    border: 2px solid #333;
  }

  @media (max-width: 1200px) {
    .sider-left,
    .sider-right,
    .sample-bot-section {
      display: none !important;
    }
    .gomoku-bottom-bar {
      display: flex !important;
    }
  }
  .gomoku-bottom-bar {
    display: none;
    justify-content: center;
    gap: 2rem;
    margin: 2rem auto 0 auto;
    max-width: 600px;
  }
  .gomoku-bottom-bar .bottom-side {
    flex: 1 1 0;
    background: #f8fafc;
    border-radius: 1rem;
    box-shadow: 0 2px 8px rgba(0,0,0,0.04);
    padding: 1.5rem;
    min-width: 0;
    max-width: 260px;
  }
</style>
<div class="bg-gray-100 py-10">
  <div class="max-w-screen-xl mx-auto">
    <!-- Header Section
    <header class="text-center mb-8">
      <h1 class="text-4xl font-bold text-gray-800">Gomoku</h1>
      
    </header> -->

    

    <!-- Game Canvas Section -->
    <!-- <div class="bg-white p-6 rounded-lg shadow-md text-center"> -->
      <div style="position:relative;width:100%;max-width:600px;height:auto;margin:auto;box-sizing:border-box;">
        <div id="phaser-container" style="width:100%;height:100%;"></div>
      </div>
      <br>
      <div style="text-align:center;">
        <button type="button" onclick="newGame()" class="mt-4 px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600">New Game</button>
      </div>

    <!-- </div> -->

    <br>
      <div style="margin-top: 2rem;"></div>
      <!-- Sample Bot Code Section -->
      <section class="sample-bot-section bg-white p-6 rounded-lg shadow-md mb-8">
        <h2 class="text-xl font-bold mb-4">Sample Bot Code (Python)</h2>
        <pre class="bg-gray-100 p-4 rounded-lg border border-gray-300" style="white-space: pre-wrap; word-break: break-word;">
<code class="language-python">
import json
import random

EMPTY = 0

def main():
    data = json.loads(input())
    move_history = data.get("move_history", [])
    board = [[EMPTY] * 15 for _ in range(15)]
    for i, m in enumerate(move_history):
        board[m["y"]][m["x"]] = 1 if i % 2 == 0 else 2
    options = [
        (x, y) for y in range(15) for x in range(15) if board[y][x] == EMPTY
    ]
    if options:
        x, y = random.choice(options)
        print(json.dumps({"x": x, "y": y}))
    else:
        print(json.dumps({"error": "No valid move found or board is full."}))

if __name__ == "__main__":
    main()
</code>
        </pre>
      </section>


      <div class="gomoku-bottom-bar">
        <div class="bottom-side">
          <h2 style="font-size: 1.1rem; font-weight: bold;">Black</h2>
          <select id="aiSelectBlackBottom" class="block w-full border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm">
            {% for bot in bots %}
            <option value="{{ bot[0] }}">{{ bot[1] }}</option>
            {% endfor %}
          </select>
          <div style="margin-top:1.5rem;">
            <input type="checkbox" id="left-checkbox-bottom" />
            <label for="left-checkbox-bottom" style="margin-left:0.5rem;">Human</label>
          </div>
        </div>
        <div class="bottom-side">
          <h2 style="font-size: 1.1rem; font-weight: bold;">White</h2>
          <select id="aiSelectWhiteBottom" class="block w-full border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm">
            {% for bot in bots %}
            <option value="{{ bot[0] }}">{{ bot[1] }}</option>
            {% endfor %}
          </select>
          <div style="margin-top:1.5rem;">
            <input type="checkbox" id="right-checkbox-bottom" />
            <label for="right-checkbox-bottom" style="margin-left:0.5rem;">Human</label>
          </div>
        </div>
      </div>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.js"></script>
<script>
function getBoardSize() {
  return Math.min(window.innerWidth-70, 600);
}

let SIZE = 15;
let BOARD_SIZE = getBoardSize();
let GRID = BOARD_SIZE / SIZE;

let board = Array.from({ length: SIZE }, () => Array(SIZE).fill(0));
let lastMove = null;
let gameOver = true;
let userId = null;
let currentGameId = null;

const config = {
  type: Phaser.AUTO,
  width: BOARD_SIZE,
  height: BOARD_SIZE,
  parent: 'phaser-container',
  backgroundColor: '#f5deb3',
  scene: {
    create,
    preload,
  }
};

let phaserGame = new Phaser.Game(config);
let graphics;

function preload() {}

function create() {
  graphics = this.add.graphics();
  drawBoard();
  showPhaserMask();

  this.input.on('pointerdown', pointer => {
    if (gameOver || maskRect) return;
    const x = Math.floor(pointer.x / GRID);
    const y = Math.floor(pointer.y / GRID);
    if (board[y][x] !== 0) return;
    sendPlayerMove(x, y);
  });
}

function drawBoard() {
  graphics.clear();

  // Draw grid
  graphics.lineStyle(1, 0x333333, 1);
  for (let i = 0; i < SIZE; i++) {
    graphics.lineBetween(GRID / 2, GRID / 2 + i * GRID, GRID * (SIZE - 0.5), GRID / 2 + i * GRID);
    graphics.lineBetween(GRID / 2 + i * GRID, GRID / 2, GRID / 2 + i * GRID, GRID * (SIZE - 0.5));
  }

  // Draw star points
  const starPoints = [
    [3, 3], [3, 11], [7, 7], [11, 3], [11, 11]
  ];
  for (let [x, y] of starPoints) {
    graphics.fillStyle(0x333333, 1);
    graphics.fillCircle(GRID / 2 + x * GRID, GRID / 2 + y * GRID, 5);
  }

  // Draw stones
  for (let y = 0; y < SIZE; y++) {
    for (let x = 0; x < SIZE; x++) {
      if (board[y][x] !== 0) {
        drawStone(x, y, board[y][x] === 1);
      }
    }
  }

  if (lastMove) {
    highlightMove(lastMove.x, lastMove.y);
  }
}

function drawStone(x, y, isBlack) {
  graphics.fillStyle(isBlack ? 0x000000 : 0xffffff, 1);
  graphics.fillCircle(GRID / 2 + x * GRID, GRID / 2 + y * GRID, GRID / 2.5);
  graphics.lineStyle(1, 0x333333, 1);
  graphics.strokeCircle(GRID / 2 + x * GRID, GRID / 2 + y * GRID, GRID / 2.5);
}

function highlightMove(x, y) {
  graphics.fillStyle(0xff3333, 1);
  graphics.fillCircle(GRID / 2 + x * GRID, GRID / 2 + y * GRID, GRID / 10);
}

const socket = io('/gomoku');
socket.on('connect', () => {});

socket.on('init', (data) => {
  userId = data.user_id;
});

socket.on('update', (data) => {
  if (data.game_id) {
    currentGameId = data.game_id;
  }
  board = data.board;
  if (data.move) {
    lastMove = { x: data.move.x, y: data.move.y };
  } else if (data.ai_move) {
    lastMove = { x: data.ai_move.x, y: data.ai_move.y };
  } else {
    lastMove = null;
  }
  drawBoard();

  if (data.winner) {
    let msg = '';
    if (data.winner === 1) {
      msg = 'Black wins!';
    } else if (data.winner === 2) {
      msg = 'White wins!';
    } else {
      msg = 'Draw!';
    }
    showPhaserMask(msg);
    gameOver = true;
  } else {
    hidePhaserMask();
  }
});

let maskRect = null;
let maskText = null;

function showPhaserMask(msg = "Waiting for new game...") {
  hidePhaserMask();
  maskRect = graphics.scene.add.rectangle(
    BOARD_SIZE / 2, BOARD_SIZE / 2, BOARD_SIZE, BOARD_SIZE,
    0x000000, 0.25
  ).setDepth(1000);
  maskText = graphics.scene.add.text(
    BOARD_SIZE / 2, BOARD_SIZE / 2, msg,
    { fontSize: Math.floor(BOARD_SIZE / 18) + 'px', color: '#fff', fontStyle: 'bold' }
  ).setOrigin(0.5).setDepth(1001);
}

function hidePhaserMask() {
  if (maskRect) { maskRect.destroy(); maskRect = null; }
  if (maskText) { maskText.destroy(); maskText = null; }
}


function newGame() {
  const blackBot = document.getElementById('aiSelectBlack').value;
  const whiteBot = document.getElementById('aiSelectWhite').value;
  const blackisHuman = document.getElementById('left-checkbox').checked;
  const whiteisHuman = document.getElementById('right-checkbox').checked;
  socket.emit('new_game', {
    user_id: userId,
    black_bot: blackBot,
    white_bot: whiteBot,
    black_is_human: blackisHuman,
    white_is_human: whiteisHuman
  });

  showPhaserMask();
  gameOver = false;
  lastMove = null;
  board = Array.from({ length: SIZE }, () => Array(SIZE).fill(0));
  drawBoard();
}

function sendPlayerMove(x, y) {
  socket.emit('player_move', { user_id: userId, x, y, game_id: currentGameId });
}


window.addEventListener('resize', () => {
  BOARD_SIZE = getBoardSize();
  GRID = BOARD_SIZE / SIZE;
  phaserGame.scale.resize(BOARD_SIZE, BOARD_SIZE);
  drawBoard();
  if (maskRect || maskText) {
    let msg = maskText ? maskText.text : "Waiting for new game...";
    showPhaserMask(msg);
  }
});
</script>
<link href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism.min.css" rel="stylesheet" />
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-python.min.js"></script>
<script>
document.addEventListener('DOMContentLoaded', function() {
  const left = document.getElementById('left-checkbox');
  const right = document.getElementById('right-checkbox');
  if (left && right) {
    left.addEventListener('change', function() {
      if (left.checked) right.checked = false;
    });
    right.addEventListener('change', function() {
      if (right.checked) left.checked = false;
    });
  }

  const leftBottom = document.getElementById('left-checkbox-bottom');
  const rightBottom = document.getElementById('right-checkbox-bottom');
  if (leftBottom && rightBottom) {
    leftBottom.addEventListener('change', function() {
      if (leftBottom.checked) rightBottom.checked = false;
    });
    rightBottom.addEventListener('change', function() {
      if (rightBottom.checked) leftBottom.checked = false;
    });
  }
});
</script>
{% endblock %}